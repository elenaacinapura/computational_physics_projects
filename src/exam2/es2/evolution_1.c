#include <stdio.h>
#include <math.h>
#include <complex.h>
#include <assert.h>
#include <gsl/gsl_fft_complex.h>
#include <print_routines.h>
#include <linear_algebra/blas_wrappers.h>

/* --------------------------- */
#define EPS 1e-6

/* --------------------------- */
void read_ground(double x[], double psi[], int N);
double potential(double x);
void evolution_step(complex double psi[], complex double rho[], complex double eta[], int N);
// void calculate_norms(double x[], complex double psi[], double *n1, double *n2);

/************************** MAIN *********************************/
int main(){

    /* parameters */
    double xi = 0.015;
    double L = 2.0 * 4.096;

    /* ground state energy */
    double E_0 = -0.018028;
    int N = 2 * 4096;
    double dx, x[N], psi0[N], psi[N], V[N];
    read_ground(x,psi,N);
    vec_copy(N,psi,psi0);
    dx = x[1] - x[0];


    /* split operator method */
    double T = 1000.0;
    double dt = 0.001;
    complex double K, rho[N], eta[N];
    
    for(int i=0;i<N;i++){

        V[i] = potential(x[i]);
        rho[i] = cexp(-I * V[i] * dt);
        K = I * 2 * M_PI / L * ( i <= N/2 ? i : i - N );
        eta[i] = cexp( I * xi * K * K * dt );

    }

    /* complexification of psi */
    complex double Psi[N];
    for(int i=0;i<N;i++){
        Psi[i] = psi[i];
    }

    /* evolution */
    double t = 0.0;
    do{

        evolution_step(Psi,rho,eta,N);
        t += dt;

    }while(t < T);

    
    /* test */
    FILE *fp;
    fp = fopen("ground.csv","w");
    for(int i=0;i<N;i++){
        fprint_double(fp,x[i]);
        fprint_double(fp,V[i]);
        fprint_double(fp,creal(Psi[i]));
        fprint_double_newline(fp,cimag(Psi[i]));
    }
    fclose(fp);


}
/*****************************************************************/
void read_ground(double x[], double psi[], int N){
    
    /* read from file the ground state wave function */
    assert(N = 2 * 4096);
    int N_prov = N / 2;
    double x_prov[N_prov], psi_prov[N_prov];
    FILE *f_psi;
    f_psi = fopen("eigenfunction.csv","r");
    assert(f_psi != NULL);
    for(int i=0;i<N_prov;i++){
        fscanf(f_psi,"%lf%lf",&x_prov[i],&psi_prov[i]);
    }
    fclose(f_psi);

    /* initialize vectors */
    double dx = x_prov[1] - x_prov[0];
    for(int i=0;i<N;i++){
        if(i<N_prov){
            x[i] = x_prov[i];
            psi[i] = psi_prov[i];
        }else{
            x[i] = x[i-1] + dx;
            psi[i] = 0.0;
        }
    }

    /* check normalization */
    double norm = 0.0;
    for(int i=0;i<N;i++){
        norm += psi[i] * psi[i] * dx;
    }
    assert(fabs(norm - 1.0) < EPS);

}

double potential(double x){
    if(x < 0){
        return - x * x * (x + 1);
    }
    return x * x * (x - 1);
}

void evolution_step(complex double psi[], complex double rho[], complex double eta[], int N){

    /* potential phase shift */
    for(int i=0;i<N;i++){
        psi[i] *= rho[i];
    }

    /* kinetic energy phase shift */
    gsl_fft_complex_radix2_forward((double *)psi,1,N);

    for(int i=0;i<N;i++){
        psi[i] *= eta[i];
    }

    gsl_fft_complex_radix2_inverse((double *)psi,1,N);
}

// void calculate_norms(double x[], complex double psi[], double *n1, double *n2){
//     int cnt = 0;

//     *n1 = 0.0;
//     while(x[cnt] < 0.0){
//         *n1 += pow(cabs(psi[cnt]),2);
//         cnt++;
//     }
//     *n2 = 0.0;
//     while(cnt < N){
//         *n2 += pow(cabs(psi[cnt]),2);
//}